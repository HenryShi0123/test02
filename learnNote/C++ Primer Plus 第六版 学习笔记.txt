
C++的三种编程方式：
	1. 面向过程的编程方式
	2. 面向对象的编程方式
	3. 模板支持的泛型编程
	
计算机语言要处理的两个概念：
	数据  数据就是程序使用和处理的信息
	算法  算法是程序使用的方法
	
C语言编程原理（面向过程的编程）
	过程性就意味着强调编程的算法方面。
	结构化编程
	自顶而下的设计。将大型程序分解成小型、便于管理的任务。
	
面向对象编程（OOP）
	OOP强调的是数据，试图让语言类满足温度要求，
	类是一种规范，描述了这种新型数据格式，对象是根据这种规范构造的特性数据结构。
	通常类规定了可使用那些数据来表示对象以及可以对这些数据执行那些操作。
	OOP程序设计方法首先设计类，它们准确的表示了程序要处理的东西。然后便可以设计一个使
用这些类的对象的程序。
	OOP还有助于创建可重用的代码。信息隐藏可以保护数据，使其避免不适当的访问。多态可以
为运算符和函数创建多个定义，通过编程上下文来确定使用哪个定义。继承可以使用旧类派生出
新类。

C++和泛型编程
	重用代码和抽象通用概念。泛型编程强调的是独立于特性数据类型。泛型指的是的独立与类
型的代码。

C++语法要求main（）函数的定义以函数头 int main()开始。
	
C++注释
	//
	/*......*/
	注释的目的不仅仅在于帮助他人理解代码，更有助于程序员自己理解代码。
	
C++预处理器和iostream文件
	如果程序要使用C++输入或输出工具，必须使用下面两行代码：
	#include <iostream>
	using namespace std;

	声明语句和变量。
		int i;
	赋值语句
		将值赋给存储单元。
		int i;//变量声明语句
		i = 2;//赋值语句。
		
输入输出流
	cout << "this is a print function!" << 1 << endl;
	int value;
	cin >> value;
	
函数格式
	type functionname(argumentlist)
	{
		statements;
	}
	
第三章 处理数据
	3.1 简单变量
		3.1.1 变量名：
			1. 在名称中只能使用字母，数字，下划线
			2. 名称的第一个字符不能是数字
			3. 区分大写字符与小写字符。也就是说大小写字符分别代表不同意义
			4. 不能将C++关键字用作名称
			5. 以两个下划线或下划线和大写字母打头的名称被保留实现（编译器及其使用的
			资源―）使用。以一个下划线 开头的名称被保留给实现，用作全局标识符。
			6. C++对于名称的长度没有限制，名称中所有的字符都有意义，但是有些平台有
			长度限制。
		3.1.2 整型
			short 		至少16位
			int			至少与short一样长
			long		至少32位，且至少与int一样长
			long long   至少64位，且至少与long一样长
			
			可以使用sizeof运算符来计算类型或变量的长度，单位是字节。
			头文件climits中包含了关于整型限制的信息.如整型的最大值INT_MAX
			
			1. 变量初始化
				将赋值与声明合并在一起。如：
					int iInt = INT_MAX.
			2. C++11 初始化方式
				int hamburgers = {24}; //set hamburgers to 24
				int enum{7};           //set enum to 7
				int rheas = {12};	   //set rheas to 12
				int rocs{};		       //set rocs to 0
				int psychics = {};	   //set psychics to 0 
			3.1.4 无符号类型
			    用关键字unsigned修饰的基本整形就是无符号类型。无符号类型的数值范围是从0到最大值。
			        unsigned int a;
			        unsigned short b;
			        unsigned long c;
			        unsigned long long d;
			        unsigned e;
			    其中unsigned本身就是unsigned int的缩写。
			3.1.5 如何选择整形类型
			    一般选择int类型。但是如果所要表示的数值大小超出int的最大值，则应该选择long 或long 
			long，如果考虑要节省内存，则应该用跟小的short或char型。
			3.1.6 整形字面值
			    整形字面值（常量）是显示地书写的常量。
			3.1.7 常量的后缀
			    l或L  表示该整数为long
			    u或U  表示unsigend int常量
			    ul    大小写都行表示unsigned long
			    ULL   C++11 中表示unsigned long long
			3.1.8 char类型
			    char类型，转为存储字符设计，也可以用来存比short更小的整形。
			    
			    cout.put()函数，该函数显示一个字符。
			3.1.9 bool类型
			    bool类型只有两个值：true 和 false
			
		3.2 const 限定符
		    使用const关键字来修改声明和初始化，可以使一个变量不变成常量。
		    const int i = 12；//定义了一个常量，值是12
		3.3 浮点数
		    double 
		    float 
		    3.3.1 书写浮点数
		        1.2
		        3.2
		        3.2e6; //3.2 * 10^6
		        3.2e-4;//3.2 *10^-6
		    3.3.2 浮点类型
		        float
		        double
		        long double
		3.4 C++算术运算符
		    + - * / %
		    3.4.1 运算符优先级和结核性
		        先乘除，后加减 当两个运算符的优先级相同时，c++将依据操作数的结合性来进行计算。
		    3.4.2 求模运算符 %
		    3.4.4 类型转换
		        自动转换
		        将一种算术类型的值赋给另一种算术类型的变量时，C++将对值进行转换
		        表达式中包含不同的类型时，C++将对值进行转换
		        将参数传递给函数时，C++将对值进行转换。
		        1. 初始化和赋值进行的转换。
		            将一个值赋给取值范围更大的类型通常不会导致问题，但是反之则不然。
		        2. 以{}方式初始化时进行的转换（C++11）
		            使用大括号的初始化称为列表初始化，因为这种初始化常用于给复杂的数据类型提供值列表。列表
		        初始化不允许缩窄。例如：不允许将浮点数转换为整形。
		        3. 表达式中的转换
		            1. 如果有一个操作数的类型是long double ，则将另一个操作数转换为long double
		            2. 否则，如果有一个操作数的类型是double，则将另一个操作数转换为double
		            3. 否则，如果有一个操作数的类型是float，则将另一个操作数转换为float
		            4. 否则，说明操作数都是整形，因此执行整形提升。
		            5. 在这种情况下，如果两个操作数都是有符号或无符号的，且其中一个操作数的级别比另一个低，则
		        转换位级别高的类型。
		            6. 如果一个操作数是有符号的，另一个操作数是无符号的，且无符号操作数的级别比有符号操作数
		        高，则将有符号操作数转换为无符号操作数所属的类型。
		            7. 否则，如果有符号零星可表示无符号类型的所有可能取值，则将无符号数转换为有符号数操作数
		        所属的类型。
		            8. 否则，将两个操作数都转换为有符号类型的无符号版本。
		        4 传递参数是的转换
		            
		        5 强制类型转换。
		            强制类型转换有两种格式：
		                (long) thorn; // return a type long conversion of thorn 
		                long (thorn); // return a type long conversion of thorn
		   3.4.5 C++ 11中的auto声明
第4章 复合类型
    创建和使用数组
    创建和使用C风格字符串
    创建和使用string类字符串
    使用方法getline（）和get（）读取字符串
    混合输入字符串和数字
    创建和使用结构
    创建和使用共用体。
    创建和使用枚举
    创建和使用指针
    使用new和delete管理动态内存
    创建动态数组
    创建动态结构
    自动存储，静态存储和动态存储
    vector和array类简介。
    4.1 数组
        数组的声明应指出以下三点：
            1. 存储在每个元素中的值的类型
            2. 数组名
            3. 数组中的元素数
        声明数组的通用格式如下：
        typename arrayName[arraySize];             
        对数组元素的访问的方法是使用下标或索引来对元素进行编号。从0开始。
        4.1.2 数组的初始化规则
            只有在定义数组时才能使用初始化，不能将一个数组赋给另一个数组。
            int cards[4] = {3, 6, 8, 9}; //okey
            int hand[4];                 //okey
            hand[4] = {5, 6, 7, 9};      // not allowed
            hand = cards;                // not allowed
            初始化数组时，提供的值可以少于数组的元素数目。如果只对数组的一部分进行初始化，则编译器把其他元素
        设置位0.可以将数组中所有的元素都初始化位0.
            float hotelTips[5] = {4.4, 2.3};
        long  totals[500] = {0};
        4.1.3 C++数组初始化方法
            C++11 将使用大括号的初始化作为一种通用初始化方式，可用于所有类型。
            1 初始化数组时，可以省略等号
                double earnings[4]{1.23e4, 1.6e4, 1.1e4, 1.7e4};
            2 可以不在大括号内包含任何东西，这将把所有元素都设置成0
                unsigned int counts[10] = {};
                float balances[100]{};
            3 列表初始化禁止缩窄转换
	4.2 字符串
		字符串是存储在内存的连续字节中的一系列字符。C++处理字符串的方式有两种。第一
	中来自C语言，称为C风格字符串，另一种基于string类库的方法。
		C风格字符串以空字符结尾，空字符被写作 \0.
		
		char cat[8]   = {'f', 'a', 't', 'e', 's', 's', 'a', '\0'};
		char bird[11] = "Mr. Cheeps";
		char fish[]   = "Bubbles";
		用引号括起来的字符串隐式的包括结尾的空字符。
		4.2.1 拼接字符串常量
			任何两个由空白（空格、制表符和换行符）分割的字符串常量都将自动拼接成一个
		。因此下面两句等效：
			cout << "I`d give my right arm to be" " a great violinist.\n";
			cout << "I`d give my right arm to be a great violinist.\n";
			cout << "I`d give my right ar"
			"m to be a great violinist.\n";
		4.2.2 在数组中使用字符串
			要将字符串存储到数组中，最常用的方法：
			1. 将数组初始化为字符串常量
			2. 将键盘或文件输入读到数组中。
			char name1[15];
			char name2[15] = "Henry";
			
			cin >> name1;
		4.2.3 字符串输入
			cin >> name;
			cin使用空白（空格、制表符和换行符）来确定字符串的结束为止，即cin获取字符
		数组输入时，只能读取一个单词。
		4.2.4 每次读取一行字符串输入
			面向行的类成员函数：getline() 和 get().这两个函数都读取一行输入，直到
		换行符。getline将丢弃换行符，而get()将换行符保留在输入序列中。
			1. 面向行的输入：getline（）
			getline()函数读取整行，它使用通过回车键输入的换行符来确定输入结尾。
			用法： cin.getline();
			两个参数，第一个用来存储输入行的数组的名称，第二个是要读取的字符数。
				cin.getline(name, 30);
			2. 面向行的输入: get()
				get()众多用法中的一种和getline(void *, int)相似，但是get()不会丢弃换
			换行符。
				使用cin.get()必须注意换行符，可以用cin.get()来获取但不保存换行符。这
			样程序运行就不会有问题。
				cin.get(name.20).get();//后面的get()调用是为了去除换行符对程序的影响
			3. 空行和其他问题
				get()读取空行后将设置失效位，阻断记下来的读取。可以用cin.clear()来恢
			复输入。
		4.2.5 混合输入字符串和数字
			int year;
			cin >> year;
	4.3 string类简介。
		要使用string类，必须包含头文件：
			#include <string>
		string 类是一种用来表达字符串的类型，提供字符串的各种操作。
			string str1;
			string str2 = "panther";
			程序会自动调整str的长度。
		4.3.1 C++11字符串初始化
			可以使用列表初始化的方法初始化C-风格字符串和string对象。
			char first_data[] = {"Le chapon Dodu"};
			char second_data[]{"The Elegant Plate"};
			string third_data = {"The Bread Bowl"};
			string fourth_data{"Hank`s Fine Eats"};
		4.3.2 赋值，拼接和附加
			可以将一个string对象赋给另一个string对象。
			string str1;
			string str2 = {"panther"};
			str1 = str2;
			
			合并两个字符串
			string str3;
			str3 = str1 + str2;
			str3 += str1;
		4.3.3 string类的其他操作
			cstring头文件
			int len1 = str1.size();
			int len2 = strlen(charr1);
		4.3.4 string 类I/O
	4.4 结构简介
	    同一个结构可以存储多种类型的数据。创建结构的步骤。
	        1. 定义结构描述，描述并标记能够存储在结构中的各种数据类型。
	        2. 按描述创建结构变量
	    例如：
	        struct inflatable {
	            char name[30];
	            float volume;
	            double price;
	        };
	    上面的代码定义了一个名为inflatable结构体，可以按照下面的方式创建该类型的变量：
	        inflatable hat;
	    在C++中省略struct不会出错。
	    4.4.1 结构变量初始化
	        以上面inflatable变量为例：
	            inflatable hat = {
	                "henry Shi",
	                2.1,
	                32.5    
	            };
	         这是C风格的初始化，也可以使用C++11风格的初始化
	            inflatable hat{"henry Shi", 23.2, 32.3};
	     4.4.2 结构成员的使用
	        使用成员符 (.)来使用结构成员，比如要使用hat变量的名称
	        hat.name;
	     4.4.3 可以使用其他类类型作为结构成员，比如string类
	        struct inflatable {
	            string name;
	            float volum;
	            double price;
	        };
	    4.4.4 结构数组
	        可以用结构作为一个类型，构建一个数组。
	    4.4.6 结构中的位字段
	        与C语言一样，C++允许指定占用特定位数的结构成员。字段的类型应为整形或枚举，接下来是冒号，冒号
	    后面是一个数字，指定使用的位数。可以使用没有名称的字段来提供间距。例：
	        struct torgle_register
	        {
	            unsigned int SN : 4; // 4 bits for SN value
	            unsigned int    : 4; // 4 bits unused
	            bool goodIn     : 1; // valid input
	            bool goodTorgle : 1; // successful torgling.  
	        };   
	        位段的初始化和访问和结构体一样。
	4.5 共用体
	    union one4all {
	        int int_val;
	        long long_val;
	        double double_val;
	    };
	4.6 枚举
	    enum spectrum {
	        red,
	        orange,
	        yellow,
	        green,
	        blue,
	        violet,
	        indigo,
	        ultraviolet    
	    };    
上面的代码完成两项工作
	    让spectrum成为新类型的名称。枚举类
	    将red orange，yellow作为符号常量，对应整数0~7.
	    一般情况下枚举变量只能赋值枚举量，非枚举量的赋值行为是非法的，如下：
	        spectrum band; 
	        band = 2000; //这是不合法的。
	    枚举变量不参与算术运算。
	    int类型不能自动转换为枚举类型。
	    4.6.1 设置枚举量的值
	        可以用赋值运算符来显示的设置枚举量的值：
	        enum bits {
	            one = 1,
	            two = 2,
	            four = 4, 
	            eight = 8    
	        };
	        指定的值必须是整数，也可以只显示的定义其中一些枚举量的值：
	        enum bigstep {
	            first,
	            second = 100,
	            third  
	        };
	        first 默认为0，后面没有被初始化的枚举量将比前面的枚举量大1.
	        可以创建多个值相同的枚举量
	        enum {zero, null = 0, one, numero_uno = 1};
	     4.6.2 枚举的取值范围
	        每个枚举都有取值范围，通过强制类型转换，可以将取值范围中的任何整数值给枚举变量。
	        enum bits {one = 1, two = 2, four = 4, eight = 8};
	        bits myflag;
	        myflag = bits(6);  
	        
	        取值范围的定义：
	            计算上限：首先需要知道枚举量的最大值， 找到大于这个最大值的，最小的2的幂，将它
	        减去1，得到的便是取值范围的上限。
	            计算下限。如果最小值不小于0，则取值范围为0；否则，采用与寻找上限方式相同的方式，
	        但要加上负号。
	4.7 指针和自由存储空间
	    计算机在存储数据时必须跟踪三种属性：
	        1. 信息存储的位置
	        2. 存储的值为多少
	        4. 存储的信息的类型。
	     指针是一个变量，其存储的是值的地址，而不是值本身。
	     取址符&可以获取一个变量的地址。
	     取值符*可以得到该地址处存储的值。
	        
		4.7.1 声明和初始化指针
			类型 * 名称；
			例如：int * p_updates;
			初始化
			int higgens = 5；
			int* pt = &higgens;
		4.7.2 指针的危险
			在C++中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针
		所指向的数据的内存。为数据提供空间是一个独立的步骤。
			
			警告：
				一定要在对指针应用接触引用运算符（*）之前，将指针初始化为一个确定的、
			适当的地址。不然会导致一些隐蔽的，不容易追踪的bug出现。
		4.7.3 指针和数字
			1 不能将整数简单的赋给指针，在C++中，要将数字值作为地址来使用，应通过强制
		类型转换将数字转换为适当的地址类型：
			int *pt;
			pt = (int *)0xB8000000;
		4.7.4 使用new来分配内存
		    int *pn = new int;
		    变量的值都存储在栈的内存区域中，而new从被称为堆（heap）或自由存储区（free store）的内存区域
		分配内存。
		4.7.5 使用delete释放内存
		    int * ps = new int;
		    
		    delete ps;
		    delete 一定要和new配对使用，否则会放生内存泄漏。
		4.7.6 使用new创建动态数组
		    动态数组：需要的时候创建，不需要的时候不创建，还可以在程序运行的时候选择数组的长度
	        
	        1. 使用new创建动态数组
	            int * psome = new int[10];
	            对于使用new创建的数组，应使用delete的另一种格式来释放
	            delete [] psome;
	            使用new和delete时，应遵循下面的规则
	                1. 不要使用delete来释放不是new分配的内存
	                2. 不要使用delete释放同一个内存块两次
	                3. 如果使用new[]为数组分配内存，则应使用delete[]来释放
	                4. 如果用new[]为一个实体分配内存，则应使用delete来释放
	                5. 对空指针应用delete是安全的。
	            为数组分配内存的通用格式如下：
	            type_name * pointer_name = new type_name[num_elements];
	            使用new运算符可以确保内存块足以存储num_elements个类型位type_name的元素，而pointer_name
	        将指向第一个元素。
	        2. 使用动态数组
	           可以按照使用数组的方式，使用new分配的指针。
    4.8 指针/数组/指针算术
        将指针变量增加1后，增加的量等于它指向的类型的字节数。    
		4.8.2 指针小结
		    1. 声明指针
		        typename *pointerName;
		    2. 给指针赋值
		        可以对变量名应用&运算符，来获取被命名的内存的地址，new运算符返回未命名的内存的地址。
		    3. 对指针解除引用
		        对指针解除引用或间接值运算符来解除引用。
		        使用数组表示是法
		    4. 区分指针和指针所指向的值
		        
		    5. 数组名
		        多数情况下，C++将数组名视为数组的第一个元素的地址。
		        一种例外情况是，将sizeof运算符用于数组名时，此时返回整个数组的长度。
		    6. 指针算术
		        加1的结果等于原来的地址值奖赏指向对象占用的总字节数。
		    7. 数组的动态联编和静态联编
		        使用数组声明来创建数组时，将采用静态联编，即数组的长度在编译时设置
		        使用new[]运算符创建数组时，将采用动态联编，即将在运行时位数组分配空间，其长度也是在运行时
		    设置。使用完这种，应delete[]释放其占用的内存。
		    8. 数组表示法和指针表示法
		4.8.4 使用new创建动态结构
		    使用new创建结构指针之后，使用箭头成员运算符(->)
		        struct things {
		            int good;
		            int bad;
		        };
		        
		        things grubnose = {3, 453};
		        things * pt = &grubnose;
		        pt->good;
		        pt->bad;
		4.8.5 自动存储，静态存储和动态存储
		    1. 自动存储。
		        在函数内部定义的常规变量使用自动存储空间，被称为自动变量，意味着它们在所属的函数被
		    调用时自动产生，在该函数结束时消亡。
		        自动变量存储在栈中，遵循后进先出的原则。
		     2. 静态存储
		        静态存储是整个程序执行期间都存在的存储方式。使变量称为静态的方式有两种：
		            1. 函数外面定义
		            2. 在声明变量时使用关键字static。
		     3. 动态存储
		        new和delete运算符提供了一种比自动变量和静态变量更灵活的方法。
		    
    4.9 类型组合
    4.10 数组的替代品
        4.10.1 模板类vector
            要使用vector对象，必须包含vector头文件。
            其次vector包含在名称空间std中，因此要使用using编译指令，using声明或std::vector
            第三，模板使用不同的语法来指出它存储的数据类型。
            第四，vector类使用不同的语法来指定元素
            #include <vector>
            
            using namespace std;
            vector<int> vi;
            int n;
            cin >> n;
            vector<double> vd(n);
            下面的声明创建一个名为vt的vector对象，可存储n_elem个类型位typeName的元素：
            vector<typename> vt(n_elem);
        4.10.2 模板类array
            vector类的功能比数组强大，但是付出的代价是效率稍低。模板类array，效率与数组相同，但比数组
        更方便，更安全。要创建array对象，需要包含头文件array。
        
            #include <array>
            using name std;
            array<int, 5> ai; // create array object of 5 ints;
            array<double, 4> ad = {1.2, 2.1, 3.43, 4.3};
         4.10.3 比较数组，vector对象和array对象
第五章 循环和关系表达式
    for循环
    表达式和语句
    递增运算符和递减运算符：++ --
    组合赋值运算符
    复合语句（语句块）
    逗号运算符
    关系运算符：> >= == < <= & !=
    while循环
    typedef工具
    do while 循环
    字符输入方法get（）
    文件尾条件
    嵌套循环和二维数组
    5.1 for 循环
    5.2 while循环
        5.2.2 等待一段时间：编写延时循环
            使用系统时钟来完成延时工作会更加的有效果。
            头文件ctime，定义了一个符号常量 CLOCKS_PER_SEC,该乘凉等于每秒包含的系统时间单位数
            	cout << "Enter the delay time, in seconds: ";
            	float secs;
            	cin >> secs;
            	clock_t delay = secs * CLOCKS_PER_SEC;
            	cout << "starting\a\n";
            	clock_t start = clock();
            	cout << "start..." << endl;
            	while (clock() - start < delay);
            
            	cout << "Done\a\n";
    5.3 do while循环
        首先执行循环体，然后再判断测试表达式，决定是否继续执行循环。
    5.4 基于范围的for循环
        C++11 新增了一种循环：基于范围（range-based)的for循环。这简化了一种常见的循环任务：对数组
    （或容器类,如vector和array）的每个元素执行相同的操作，如下：
        double prices[5] = {4.99, 10.99, 6.87, 7,99,  8,49};
        for (double x:prices) 
            cout << x << std :: endl;
    5.5 循环和文本输入
        循环最常见，最重要的任务：逐字符地读取来自文件或键盘的文本。
        cin对象支持三种不同模式的单字符输入，其用户接口各不相同。
		5.5.1 使用原始的cin进行输入
			使用哨兵字符，作为输入的停止标记。
				char ch;
				int count = 0;
				cout << "Enter characters;enter # to quit:\n";
				cin >> ch;
				while (ch != '#') {
					cout << ch;
					++count;
					cin >> ch;
				}
				cout << endl << count << " characters read\n";
			目前该程序有个问题，不能识别空格。
			这是因为cin在读取char值时，与读取其他基本类型一样，cin将忽略空格和换行符
		5.5.2 使用cin.get(char)进行补救
			cin.get(char)函数可以检查每个字符，包括空格，制表符和换行符。
		5.5.3 使用哪个cin.get()
			函数重载
		5.5.4 文件尾条件
			如果输入来自文件，则可以使用一种功能更加强大的技术--检测文件尾（EOF）。
		很多PC编程环境都将ctrl+Z视为模拟EOF。
			1. EOF结束输入
				当cin方法检测到EOF时，将设置cin对象中的一个指示EOF条件的标记，并不在
			读取输入，再次调用也不管用。然而对于键盘模拟EOF来结束循环，但稍后要读取其
			他输入。cin.clear()方法可以清楚EOF标记，使输入继续进行。
			2. 常见的字符输入做法
				每次读取一个字符，直到遇到EOF的输入循环的基本设计如下：
					cin.get(ch);
					while (cin.fail() == false) {
						//....
						cin.get(ch);
					}
					
			cin.get(char)的返回值是一个cin对象。当cin出现在需要bool的地方时，该转换函
		数江北调用。
		5.5.5 另一个cin.get()版本
			在C++工程中包含头文件stdio.h（或新的cstdio），就可以用getchar（）和
			putchar().
	5.6 嵌套循环和二维数组
		二维数组：
			int maxtemps[4][5];
			这意味着maxtemps是一个包含4个元素的数组，其中每个元素都是一个由5个整数组
		的数组。
		5.6.1 初始化二维数组
			。。。。。。
		5.6.2 使用二维数组
第6章 分支语句和逻辑运算符
	if 语句
	if else 语句
	逻辑运算符：&&，||，！
	cctype 字符函数库
	条件运算符
	switch 语句
	continue 和 break语句
	读取数字的循环
	基本文件输入和输出
	6.1 if 语句
		if (test-condition) 
			statement;
		6.1.1 if else 语句
			if (test-condition) 
				statement1;
			else 
				statement2;
	6.2 逻辑表达式
		或运算符 ||
		与运算符 &&
		非运算符 ！
	6.3 字符函数库cctype
		头文件cctype中定义了一些与字符相关的，非常方便的函数。
		isalpha(char) 判断是否为一个字母
		ispunct(char) 判断是否为标点符号
	6.4 条件运算符
		expression1 ? expression2 : expression3
	6.5 switch 语句
		switch (integer-expression)
		{
			case label1: statement(s);
				(break;)
			case label2: statement(s);
			...
			default : statement(s);
			
			
		}
	6.6 break 和 continue 语句
		break 可以用在switch语句或任何循环中，作用是跳出switch或循环语句，执行后面的
	代码
		continue 语句用在循环中，作用是跳出循环中的剩下的代码，重新开始新的循环。
	
	6.7 读取数字的循环
		使用cin时，如果发生输入数据的类型和cin要指向的类型不匹配的时候会发生种情况：
	例如：
		int n；
		cin >> n;
		1. n的值保持不变
		2. 不匹配的输入将留在输入队列中；
		3. cin对象中的一个错误标记被设置；
		4. 对cin方法的调用将返回false；
	
			double fish[MAX];

			cout << "Please enter the weights of your fish.\n";
			cout << "You may enter up to " << MAX << " fish <q to terminate>.\n";
			cout << "Fish #1: ";
			int im = 0;
			while (im < MAX && cin >> fish[im]) {
				if (++im < MAX)
					cout << "fish #" << im + 1 << ":";
			}
			//calculate average
			double total01 = 0.0;
			int jm;
			for (jm = 0; jm < im; jm++) {
				total01 += fish[jm];
			}
			if (im == 0) {
				cout << "No fish\n";
			} else {
				cout << total01 / im << " = average weight of " << im << " fish\n";
			}
			cout << "Done.\n";
			
		上面的程序出现什么情况呢，就是当用户非法输入的时候，程序将不再读取输入。我们
	希望的时，在接收到非法输入的时候，继续读取。
		当程序发现用户输入错误内容时，应采取三个步骤。
		1. 重置cin以接收新的 输入
		2. 删除错误输入
		3. 提示用户再输入。
		    while (!(cin >> golf[in])) {
			cin.clear();//reset input 
			while (cin.get() != '\n') {
				//i--;
				continue;// get rid of bad input
			}
			cout << "Please enter a number: ";
		   }
		   
	6.8 简单文件输入、输出
		简单的介绍文本文件I/O。
		6.8.1 文本I/O和文本文件
				。。。。。。
		6.8.2 写入到文本文件中
			有关将cout用于控制台输出的基本事实
			1. 必须包含头文件iostream。
			2. 头文件iostream定义了一个用处理输出的ostream类
			3. 头文件iostream声明了一个名为cout的ostream变量
			4. 必须指明使用名称空间：std；例如，为引用元素cout和endl，不许使用编译
			   指令using或前缀std::
			5. 可以结合使用cout和运算符<<来显示各种类型的数据
			文件输出与此类似
			1. 必须包含头文件fstream
			2. 头文件fstream定义了一个用于处理输出的ofstream类
			3. 需要声明一个或多个ofstream变量，并以自己喜欢的方式对其进行命名，条件是
			   遵守常用的命名规则
			4. 必须指明名称空间std；例如，为引用元素ofstream，必须使用编译指令using或
			   前缀std::.
			5. 需要将ofstream与文件关联起来。为此，方法之一就是使用open()方法。
			6. 使用完文件后，应使用方法close()将其关闭。
			7. 可以结合使用ofstream对象和运算符<<来输出各种类型的数据。
			必须声明自己的ofstream对象，为其命名，并将其同文件关联起来。
			ofstream outFile;
			ofstream fout;
			如何将这种对象与特定的文件关联起来。
			outFile.open("fish.txt"); //outFile used to write to the fish.txt file
			char filename[50];
			cin >> filename; //user specifies a name
			fout.open(filename);//fout used to read specified file
			
			方法open()接受一个C风格字符串作为参数，可以是一个字面字符串，也可以是一个
		存储在数组中的字符串。
			
			double wt = 124.8;
			outFile << wt; //write a number to fish.txt
			char line[81] = "Objects are closer than they appear.";
			fout << line << endl;
			
			方法close()不需要使用文件名作为参数。如果程序中忘记关闭文件，程序正常终止
		时将自动关闭。
			fstream 对象可以使用cout可使用的任何方法，包括<< 和各种格式化方法，如
		setf() 和 precision().
			
			open()方法。
			如果参数指定的文件不存在，则新建一个名为参数中指定的文件。如果指定的文件
		存在，则将原文件中的内容删除，等待新的操作。
		6.8.3 读取文本文件
			1. 必须包含头文件fstream
			2. 头文件fstream定义了一个用于处理输入的ifstream类
			3. 需要声明一个或多个ifstream变量（对象），并命名
			4. 必须指明名称空间std
			5. 需要将ifstream对象与文件关联起来，为此，方法之一是使用open（）方法
			6. 使用完文件后，应使用close（）方法将其关闭
			7. 可以使用ifstream对象和get（）方法来读取一个字符，使用ifstream对象
			   和getline（）方法来读取一行字符。
			8. 可以结合使用ifstream和eof(), fail()等方法来判断输入是否成功。
			9. ifstream对象本身被用作测试条件时，如果最后一个读取操作成功，它将被转换
			   为布尔值true，否则为false。
			   
		    如何声明ifstream对象，为其命名及同文件关联起来。
			ifstream inFile;//inFile an ifstream object 
			ifstream fin; //fin an ifstream object
			
			inFile.open("bowling.txt");//inFile used to read bowling.txt file
			char filename[50];
			cin >> filename;
			fin.open(filename);