
C++的三种编程方式：
	1. 面向过程的编程方式
	2. 面向对象的编程方式
	3. 模板支持的泛型编程
	
计算机语言要处理的两个概念：
	数据  数据就是程序使用和处理的信息
	算法  算法是程序使用的方法
	
C语言编程原理（面向过程的编程）
	过程性就意味着强调编程的算法方面。
	结构化编程
	自顶而下的设计。将大型程序分解成小型、便于管理的任务。
	
面向对象编程（OOP）
	OOP强调的是数据，试图让语言类满足温度要求，
	类是一种规范，描述了这种新型数据格式，对象是根据这种规范构造的特性数据结构。
	通常类规定了可使用那些数据来表示对象以及可以对这些数据执行那些操作。
	OOP程序设计方法首先设计类，它们准确的表示了程序要处理的东西。然后便可以设计一个使
用这些类的对象的程序。
	OOP还有助于创建可重用的代码。信息隐藏可以保护数据，使其避免不适当的访问。多态可以
为运算符和函数创建多个定义，通过编程上下文来确定使用哪个定义。继承可以使用旧类派生出
新类。

C++和泛型编程
	重用代码和抽象通用概念。泛型编程强调的是独立于特性数据类型。泛型指的是的独立与类
型的代码。

C++语法要求main（）函数的定义以函数头 int main()开始。
	
C++注释
	//
	/*......*/
	注释的目的不仅仅在于帮助他人理解代码，更有助于程序员自己理解代码。
	
C++预处理器和iostream文件
	如果程序要使用C++输入或输出工具，必须使用下面两行代码：
	#include <iostream>
	using namespace std;

	声明语句和变量。
		int i;
	赋值语句
		将值赋给存储单元。
		int i;//变量声明语句
		i = 2;//赋值语句。
		
输入输出流
	cout << "this is a print function!" << 1 << endl;
	int value;
	cin >> value;
	
函数格式
	type functionname(argumentlist)
	{
		statements;
	}
	
第三章 处理数据
	3.1 简单变量
		3.1.1 变量名：
			1. 在名称中只能使用字母，数字，下划线
			2. 名称的第一个字符不能是数字
			3. 区分大写字符与小写字符。也就是说大小写字符分别代表不同意义
			4. 不能将C++关键字用作名称
			5. 以两个下划线或下划线和大写字母打头的名称被保留实现（编译器及其使用的
			资源―）使用。以一个下划线 开头的名称被保留给实现，用作全局标识符。
			6. C++对于名称的长度没有限制，名称中所有的字符都有意义，但是有些平台有
			长度限制。
		3.1.2 整型
			short 		至少16位
			int			至少与short一样长
			long		至少32位，且至少与int一样长
			long long   至少64位，且至少与long一样长
			
			可以使用sizeof运算符来计算类型或变量的长度，单位是字节。
			头文件climits中包含了关于整型限制的信息.如整型的最大值INT_MAX
			
			1. 变量初始化
				将赋值与声明合并在一起。如：
					int iInt = INT_MAX.
			2. C++11 初始化方式
				int hamburgers = {24}; //set hamburgers to 24
				int enum{7};           //set enum to 7
				int rheas = {12};	   //set rheas to 12
				int rocs{};		       //set rocs to 0
				int psychics = {};	   //set psychics to 0 
			3.1.4 无符号类型
			    用关键字unsigned修饰的基本整形就是无符号类型。无符号类型的数值范围是从0到最大值。
			        unsigned int a;
			        unsigned short b;
			        unsigned long c;
			        unsigned long long d;
			        unsigned e;
			    其中unsigned本身就是unsigned int的缩写。
			3.1.5 如何选择整形类型
			    一般选择int类型。但是如果所要表示的数值大小超出int的最大值，则应该选择long 或long 
			long，如果考虑要节省内存，则应该用跟小的short或char型。
			3.1.6 整形字面值
			    整形字面值（常量）是显示地书写的常量。
			3.1.7 常量的后缀
			    l或L  表示该整数为long
			    u或U  表示unsigend int常量
			    ul    大小写都行表示unsigned long
			    ULL   C++11 中表示unsigned long long
			3.1.8 char类型
			    char类型，转为存储字符设计，也可以用来存比short更小的整形。
			    
			    cout.put()函数，该函数显示一个字符。
			3.1.9 bool类型
			    bool类型只有两个值：true 和 false
			
		3.2 const 限定符
		    使用const关键字来修改声明和初始化，可以使一个变量变成常量。
		    const int i = 12；//定义了一个常量，值是12
		3.3 浮点数
		    double 
		    float 
		    3.3.1 书写浮点数
		        1.2
		        3.2
		        3.2e6; //3.2 * 10^6
		        3.2e-4;//3.2 *10^-6
		    3.3.2 浮点类型
		        float
		        double
		        long double
		3.4 C++算术运算符
		    + - * / %
		    3.4.1 运算符优先级和结核性
		        先乘除，后加减 当两个运算符的优先级相同时，c++将依据操作数的结合性来进行计算。
		    3.4.2 求模运算符 %
		    3.4.4 类型转换
		        自动转换
		        将一种算术类型的值赋给另一种算术类型的变量时，C++将对值进行转换
		        表达式中包含不同的类型时，C++将对值进行转换
		        将参数传递给函数时，C++将对值进行转换。
		        1. 初始化和赋值进行的转换。
		            将一个值赋给取值范围更大的类型通常不会导致问题，但是反之则不然。
		        2. 以{}方式初始化时进行的转换（C++11）
		            使用大括号的初始化称为列表初始化，因为这种初始化常用于给复杂的数据类型提供值列表。列表
		        初始化不允许缩窄。例如：不允许将浮点数转换为整形。
		        3. 表达式中的转换
		            1. 如果有一个操作数的类型是long double ，则将另一个操作数转换为long double
		            2. 否则，如果有一个操作数的类型是double，则将另一个操作数转换为double
		            3. 否则，如果有一个操作数的类型是float，则将另一个操作数转换为float
		            4. 否则，说明操作数都是整形，因此执行整形提升。
		            5. 在这种情况下，如果两个操作数都是有符号或无符号的，且其中一个操作数的级别比另一个低，则
		        转换位级别高的类型。
		            6. 如果一个操作数是有符号的，另一个操作数是无符号的，且无符号操作数的级别比有符号操作数
		        高，则将有符号操作数转换为无符号操作数所属的类型。
		            7. 否则，如果有符号零星可表示无符号类型的所有可能取值，则将无符号数转换为有符号数操作数
		        所属的类型。
		            8. 否则，将两个操作数都转换为有符号类型的无符号版本。
		        4 传递参数是的转换
		            
		        5 强制类型转换。
		            强制类型转换有两种格式：
		                (long) thorn; // return a type long conversion of thorn 
		                long (thorn); // return a type long conversion of thorn
		   3.4.5 C++ 11中的auto声明
第4章 复合类型
    创建和使用数组
    创建和使用C风格字符串
    创建和使用string类字符串
    使用方法getline（）和get（）读取字符串
    混合输入字符串和数字
    创建和使用结构
    创建和使用共用体。
    创建和使用枚举
    创建和使用指针
    使用new和delete管理动态内存
    创建动态数组
    创建动态结构
    自动存储，静态存储和动态存储
    vector和array类简介。
    4.1 数组
        数组的声明应指出以下三点：
            1. 存储在每个元素中的值的类型
            2. 数组名
            3. 数组中的元素数
        声明数组的通用格式如下：
        typename arrayName[arraySize];             
        对数组元素的访问的方法是使用下标或索引来对元素进行编号。从0开始。
        4.1.2 数组的初始化规则
            只有在定义数组时才能使用初始化，不能将一个数组赋给另一个数组。
            int cards[4] = {3, 6, 8, 9}; //okey
            int hand[4];                 //okey
            hand[4] = {5, 6, 7, 9};      // not allowed
            hand = cards;                // not allowed
            初始化数组时，提供的值可以少于数组的元素数目。如果只对数组的一部分进行初始化，则编译器把其他元素
        设置位0.可以将数组中所有的元素都初始化位0.
            float hotelTips[5] = {4.4, 2.3};
        long  totals[500] = {0};
        4.1.3 C++数组初始化方法
            C++11 将使用大括号的初始化作为一种通用初始化方式，可用于所有类型。
            1 初始化数组时，可以省略等号
                double earnings[4]{1.23e4, 1.6e4, 1.1e4, 1.7e4};
            2 可以不在大括号内包含任何东西，这将把所有元素都设置成0
                unsigned int counts[10] = {};
                float balances[100]{};
            3 列表初始化禁止缩窄转换
	4.2 字符串
		字符串是存储在内存的连续字节中的一系列字符。C++处理字符串的方式有两种。第一
	中来自C语言，称为C风格字符串，另一种基于string类库的方法。
		C风格字符串以空字符结尾，空字符被写作 \0.
		
		char cat[8]   = {'f', 'a', 't', 'e', 's', 's', 'a', '\0'};
		char bird[11] = "Mr. Cheeps";
		char fish[]   = "Bubbles";
		用引号括起来的字符串隐式的包括结尾的空字符。
		4.2.1 拼接字符串常量
			任何两个由空白（空格、制表符和换行符）分割的字符串常量都将自动拼接成一个
		。因此下面两句等效：
			cout << "I`d give my right arm to be" " a great violinist.\n";
			cout << "I`d give my right arm to be a great violinist.\n";
			cout << "I`d give my right ar"
			"m to be a great violinist.\n";
		4.2.2 在数组中使用字符串
			要将字符串存储到数组中，最常用的方法：
			1. 将数组初始化为字符串常量
			2. 将键盘或文件输入读到数组中。
			char name1[15];
			char name2[15] = "Henry";
			
			cin >> name1;
		4.2.3 字符串输入
			cin >> name;
			cin使用空白（空格、制表符和换行符）来确定字符串的结束为止，即cin获取字符
		数组输入时，只能读取一个单词。
		4.2.4 每次读取一行字符串输入
			面向行的类成员函数：getline() 和 get().这两个函数都读取一行输入，直到
		换行符。getline将丢弃换行符，而get()将换行符保留在输入序列中。
			1. 面向行的输入：getline（）
			getline()函数读取整行，它使用通过回车键输入的换行符来确定输入结尾。
			用法： cin.getline();
			两个参数，第一个用来存储输入行的数组的名称，第二个是要读取的字符数。
				cin.getline(name, 30);
			2. 面向行的输入: get()
				get()众多用法中的一种和getline(void *, int)相似，但是get()不会丢弃换
			换行符。
				使用cin.get()必须注意换行符，可以用cin.get()来获取但不保存换行符。这
			样程序运行就不会有问题。
				cin.get(name.20).get();//后面的get()调用是为了去除换行符对程序的影响
			3. 空行和其他问题
				get()读取空行后将设置失效位，阻断记下来的读取。可以用cin.clear()来恢
			复输入。
		4.2.5 混合输入字符串和数字
			int year;
			cin >> year;
	4.3 string类简介。
		要使用string类，必须包含头文件：
			#include <string>
		string 类是一种用来表达字符串的类型，提供字符串的各种操作。
			string str1;
			string str2 = "panther";
			程序会自动调整str的长度。
		4.3.1 C++11字符串初始化
			可以使用列表初始化的方法初始化C-风格字符串和string对象。
			char first_data[] = {"Le chapon Dodu"};
			char second_data[]{"The Elegant Plate"};
			string third_data = {"The Bread Bowl"};
			string fourth_data{"Hank`s Fine Eats"};
		4.3.2 赋值，拼接和附加
			可以将一个string对象赋给另一个string对象。
			string str1;
			string str2 = {"panther"};
			str1 = str2;
			
			合并两个字符串
			string str3;
			str3 = str1 + str2;
			str3 += str1;
		4.3.3 string类的其他操作
			cstring头文件
			int len1 = str1.size();
			int len2 = strlen(charr1);
		4.3.4 string 类I/O
	4.4 结构简介
	    同一个结构可以存储多种类型的数据。创建结构的步骤。
	        1. 定义结构描述，描述并标记能够存储在结构中的各种数据类型。
	        2. 按描述创建结构变量
	    例如：
	        struct inflatable {
	            char name[30];
	            float volume;
	            double price;
	        };
	    上面的代码定义了一个名为inflatable结构体，可以按照下面的方式创建该类型的变量：
	        inflatable hat;
	    在C++中省略struct不会出错。
	    4.4.1 结构变量初始化
	        以上面inflatable变量为例：
	            inflatable hat = {
	                "henry Shi",
	                2.1,
	                32.5    
	            };
	         这是C风格的初始化，也可以使用C++11风格的初始化
	            inflatable hat{"henry Shi", 23.2, 32.3};
	     4.4.2 结构成员的使用
	        使用成员符 (.)来使用结构成员，比如要使用hat变量的名称
	        hat.name;
	     4.4.3 可以使用其他类类型作为结构成员，比如string类
	        struct inflatable {
	            string name;
	            float volum;
	            double price;
	        };
	    4.4.4 结构数组
	        可以用结构作为一个类型，构建一个数组。
	    4.4.6 结构中的位字段
	        与C语言一样，C++允许指定占用特定位数的结构成员。字段的类型应为整形或枚举，接下来是冒号，冒号
	    后面是一个数字，指定使用的位数。可以使用没有名称的字段来提供间距。例：
	        struct torgle_register
	        {
	            unsigned int SN : 4; // 4 bits for SN value
	            unsigned int    : 4; // 4 bits unused
	            bool goodIn     : 1; // valid input
	            bool goodTorgle : 1; // successful torgling.  
	        };   
	        位段的初始化和访问和结构体一样。
	4.5 共用体
	    union one4all {
	        int int_val;
	        long long_val;
	        double double_val;
	    };
	4.6 枚举
	    enum spectrum {
	        red,
	        orange,
	        yellow,
	        green,
	        blue,
	        violet,
	        indigo,
	        ultraviolet    
	    };    
上面的代码完成两项工作
	    让spectrum成为新类型的名称。枚举类
	    将red orange，yellow作为符号常量，对应整数0~7.
	    一般情况下枚举变量只能赋值枚举量，非枚举量的赋值行为是非法的，如下：
	        spectrum band; 
	        band = 2000; //这是不合法的。
	    枚举变量不参与算术运算。
	    int类型不能自动转换为枚举类型。
	    4.6.1 设置枚举量的值
	        可以用赋值运算符来显示的设置枚举量的值：
	        enum bits {
	            one = 1,
	            two = 2,
	            four = 4, 
	            eight = 8    
	        };
	        指定的值必须是整数，也可以只显示的定义其中一些枚举量的值：
	        enum bigstep {
	            first,
	            second = 100,
	            third  
	        };
	        first 默认为0，后面没有被初始化的枚举量将比前面的枚举量大1.
	        可以创建多个值相同的枚举量
	        enum {zero, null = 0, one, numero_uno = 1};
	     4.6.2 枚举的取值范围
	        每个枚举都有取值范围，通过强制类型转换，可以将取值范围中的任何整数值给枚举变量。
	        enum bits {one = 1, two = 2, four = 4, eight = 8};
	        bits myflag;
	        myflag = bits(6);  
	        
	        取值范围的定义：
	            计算上限：首先需要知道枚举量的最大值， 找到大于这个最大值的，最小的2的幂，将它
	        减去1，得到的便是取值范围的上限。
	            计算下限。如果最小值不小于0，则取值范围为0；否则，采用与寻找上限方式相同的方式，
	        但要加上负号。
	4.7 指针和自由存储空间
	    计算机在存储数据时必须跟踪三种属性：
	        1. 信息存储的位置
	        2. 存储的值为多少
	        4. 存储的信息的类型。
	     指针是一个变量，其存储的是值的地址，而不是值本身。
	     取址符&可以获取一个变量的地址。
	     取值符*可以得到该地址处存储的值。
	        
		4.7.1 声明和初始化指针
			类型 * 名称；
			例如：int * p_updates;
			初始化
			int higgens = 5；
			int* pt = &higgens;
		4.7.2 指针的危险
			在C++中创建指针时，计算机将分配用来存储地址的内存，但不会分配用来存储指针
		所指向的数据的内存。为数据提供空间是一个独立的步骤。
			
			警告：
				一定要在对指针应用接触引用运算符（*）之前，将指针初始化为一个确定的、
			适当的地址。不然会导致一些隐蔽的，不容易追踪的bug出现。
		4.7.3 指针和数字
			1 不能将整数简单的赋给指针，在C++中，要将数字值作为地址来使用，应通过强制
		类型转换将数字转换为适当的地址类型：
			int *pt;
			pt = (int *)0xB8000000;
		4.7.4 使用new来分配内存
		    int *pn = new int;
		    变量的值都存储在栈的内存区域中，而new从被称为堆（heap）或自由存储区（free store）的内存区域
		分配内存。
		4.7.5 使用delete释放内存
		    int * ps = new int;
		    
		    delete ps;
		    delete 一定要和new配对使用，否则会放生内存泄漏。
		4.7.6 使用new创建动态数组
		    动态数组：需要的时候创建，不需要的时候不创建，还可以在程序运行的时候选择数组的长度
	        
	        1. 使用new创建动态数组
	            int * psome = new int[10];
	            对于使用new创建的数组，应使用delete的另一种格式来释放
	            delete [] psome;
	            使用new和delete时，应遵循下面的规则
	                1. 不要使用delete来释放不是new分配的内存
	                2. 不要使用delete释放同一个内存块两次
	                3. 如果使用new[]为数组分配内存，则应使用delete[]来释放
	                4. 如果用new[]为一个实体分配内存，则应使用delete来释放
	                5. 对空指针应用delete是安全的。
	            为数组分配内存的通用格式如下：
	            type_name * pointer_name = new type_name[num_elements];
	            使用new运算符可以确保内存块足以存储num_elements个类型位type_name的元素，而pointer_name
	        将指向第一个元素。
	        2. 使用动态数组
	           可以按照使用数组的方式，使用new分配的指针。
    4.8 指针/数组/指针算术
        将指针变量增加1后，增加的量等于它指向的类型的字节数。    
		4.8.2 指针小结
		    1. 声明指针
		        typename *pointerName;
		    2. 给指针赋值
		        可以对变量名应用&运算符，来获取被命名的内存的地址，new运算符返回未命名的内存的地址。
		    3. 对指针解除引用
		        对指针解除引用或间接值运算符来解除引用。
		        使用数组表示是法
		    4. 区分指针和指针所指向的值
		        
		    5. 数组名
		        多数情况下，C++将数组名视为数组的第一个元素的地址。
		        一种例外情况是，将sizeof运算符用于数组名时，此时返回整个数组的长度。
		    6. 指针算术
		        加1的结果等于原来的地址值奖赏指向对象占用的总字节数。
		    7. 数组的动态联编和静态联编
		        使用数组声明来创建数组时，将采用静态联编，即数组的长度在编译时设置
		        使用new[]运算符创建数组时，将采用动态联编，即将在运行时位数组分配空间，其长度也是在运行时
		    设置。使用完这种，应delete[]释放其占用的内存。
		    8. 数组表示法和指针表示法
		4.8.4 使用new创建动态结构
		    使用new创建结构指针之后，使用箭头成员运算符(->)
		        struct things {
		            int good;
		            int bad;
		        };
		        
		        things grubnose = {3, 453};
		        things * pt = &grubnose;
		        pt->good;
		        pt->bad;
		4.8.5 自动存储，静态存储和动态存储
		    1. 自动存储。
		        在函数内部定义的常规变量使用自动存储空间，被称为自动变量，意味着它们在所属的函数被
		    调用时自动产生，在该函数结束时消亡。
		        自动变量存储在栈中，遵循后进先出的原则。
		     2. 静态存储
		        静态存储是整个程序执行期间都存在的存储方式。使变量称为静态的方式有两种：
		            1. 函数外面定义
		            2. 在声明变量时使用关键字static。
		     3. 动态存储
		        new和delete运算符提供了一种比自动变量和静态变量更灵活的方法。
		    
    4.9 类型组合
    4.10 数组的替代品
        4.10.1 模板类vector
            要使用vector对象，必须包含vector头文件。
            其次vector包含在名称空间std中，因此要使用using编译指令，using声明或std::vector
            第三，模板使用不同的语法来指出它存储的数据类型。
            第四，vector类使用不同的语法来指定元素
            #include <vector>
            
            using namespace std;
            vector<int> vi;
            int n;
            cin >> n;
            vector<double> vd(n);
            下面的声明创建一个名为vt的vector对象，可存储n_elem个类型位typeName的元素：
            vector<typename> vt(n_elem);
        4.10.2 模板类array
            vector类的功能比数组强大，但是付出的代价是效率稍低。模板类array，效率与数组相同，但比数组
        更方便，更安全。要创建array对象，需要包含头文件array。
        
            #include <array>
            using name std;
            array<int, 5> ai; // create array object of 5 ints;
            array<double, 4> ad = {1.2, 2.1, 3.43, 4.3};
         4.10.3 比较数组，vector对象和array对象
第五章 循环和关系表达式
    for循环
    表达式和语句
    递增运算符和递减运算符：++ --
    组合赋值运算符
    复合语句（语句块）
    逗号运算符
    关系运算符：> >= == < <= & !=
    while循环
    typedef工具
    do while 循环
    字符输入方法get（）
    文件尾条件
    嵌套循环和二维数组
    5.1 for 循环
    5.2 while循环
        5.2.2 等待一段时间：编写延时循环
            使用系统时钟来完成延时工作会更加的有效果。
            头文件ctime，定义了一个符号常量 CLOCKS_PER_SEC,该乘凉等于每秒包含的系统时间单位数
            	cout << "Enter the delay time, in seconds: ";
            	float secs;
            	cin >> secs;
            	clock_t delay = secs * CLOCKS_PER_SEC;
            	cout << "starting\a\n";
            	clock_t start = clock();
            	cout << "start..." << endl;
            	while (clock() - start < delay);
            
            	cout << "Done\a\n";
    5.3 do while循环
        首先执行循环体，然后再判断测试表达式，决定是否继续执行循环。
    5.4 基于范围的for循环
        C++11 新增了一种循环：基于范围（range-based)的for循环。这简化了一种常见的循环任务：对数组
    （或容器类,如vector和array）的每个元素执行相同的操作，如下：
        double prices[5] = {4.99, 10.99, 6.87, 7,99,  8,49};
        for (double x:prices) 
            cout << x << std :: endl;
    5.5 循环和文本输入
        循环最常见，最重要的任务：逐字符地读取来自文件或键盘的文本。
        cin对象支持三种不同模式的单字符输入，其用户接口各不相同。
		5.5.1 使用原始的cin进行输入
			使用哨兵字符，作为输入的停止标记。
				char ch;
				int count = 0;
				cout << "Enter characters;enter # to quit:\n";
				cin >> ch;
				while (ch != '#') {
					cout << ch;
					++count;
					cin >> ch;
				}
				cout << endl << count << " characters read\n";
			目前该程序有个问题，不能识别空格。
			这是因为cin在读取char值时，与读取其他基本类型一样，cin将忽略空格和换行符
		5.5.2 使用cin.get(char)进行补救
			cin.get(char)函数可以检查每个字符，包括空格，制表符和换行符。
		5.5.3 使用哪个cin.get()
			函数重载
		5.5.4 文件尾条件
			如果输入来自文件，则可以使用一种功能更加强大的技术--检测文件尾（EOF）。
		很多PC编程环境都将ctrl+Z视为模拟EOF。
			1. EOF结束输入
				当cin方法检测到EOF时，将设置cin对象中的一个指示EOF条件的标记，并不在
			读取输入，再次调用也不管用。然而对于键盘模拟EOF来结束循环，但稍后要读取其
			他输入。cin.clear()方法可以清楚EOF标记，使输入继续进行。
			2. 常见的字符输入做法
				每次读取一个字符，直到遇到EOF的输入循环的基本设计如下：
					cin.get(ch);
					while (cin.fail() == false) {
						//....
						cin.get(ch);
					}
					
			cin.get(char)的返回值是一个cin对象。当cin出现在需要bool的地方时，该转换函
		数江北调用。
		5.5.5 另一个cin.get()版本
			在C++工程中包含头文件stdio.h（或新的cstdio），就可以用getchar（）和
			putchar().
	5.6 嵌套循环和二维数组
		二维数组：
			int maxtemps[4][5];
			这意味着maxtemps是一个包含4个元素的数组，其中每个元素都是一个由5个整数组
		的数组。
		5.6.1 初始化二维数组
			。。。。。。
		5.6.2 使用二维数组
第6章 分支语句和逻辑运算符
	if 语句
	if else 语句
	逻辑运算符：&&，||，！
	cctype 字符函数库
	条件运算符
	switch 语句
	continue 和 break语句
	读取数字的循环
	基本文件输入和输出
	6.1 if 语句
		if (test-condition) 
			statement;
		6.1.1 if else 语句
			if (test-condition) 
				statement1;
			else 
				statement2;
	6.2 逻辑表达式
		或运算符 ||
		与运算符 &&
		非运算符 ！
	6.3 字符函数库cctype
		头文件cctype中定义了一些与字符相关的，非常方便的函数。
		isalpha(char) 判断是否为一个字母
		ispunct(char) 判断是否为标点符号
	6.4 条件运算符
		expression1 ? expression2 : expression3
	6.5 switch 语句
		switch (integer-expression)
		{
			case label1: statement(s);
				(break;)
			case label2: statement(s);
			...
			default : statement(s);
			
			
		}
	6.6 break 和 continue 语句
		break 可以用在switch语句或任何循环中，作用是跳出switch或循环语句，执行后面的
	代码
		continue 语句用在循环中，作用是跳出循环中的剩下的代码，重新开始新的循环。
	
	6.7 读取数字的循环
		使用cin时，如果发生输入数据的类型和cin要指向的类型不匹配的时候会发生种情况：
	例如：
		int n；
		cin >> n;
		1. n的值保持不变
		2. 不匹配的输入将留在输入队列中；
		3. cin对象中的一个错误标记被设置；
		4. 对cin方法的调用将返回false；
	
			double fish[MAX];

			cout << "Please enter the weights of your fish.\n";
			cout << "You may enter up to " << MAX << " fish <q to terminate>.\n";
			cout << "Fish #1: ";
			int im = 0;
			while (im < MAX && cin >> fish[im]) {
				if (++im < MAX)
					cout << "fish #" << im + 1 << ":";
			}
			//calculate average
			double total01 = 0.0;
			int jm;
			for (jm = 0; jm < im; jm++) {
				total01 += fish[jm];
			}
			if (im == 0) {
				cout << "No fish\n";
			} else {
				cout << total01 / im << " = average weight of " << im << " fish\n";
			}
			cout << "Done.\n";
			
		上面的程序出现什么情况呢，就是当用户非法输入的时候，程序将不再读取输入。我们
	希望的时，在接收到非法输入的时候，继续读取。
		当程序发现用户输入错误内容时，应采取三个步骤。
		1. 重置cin以接收新的 输入
		2. 删除错误输入
		3. 提示用户再输入。
		    while (!(cin >> golf[in])) {
			cin.clear();//reset input 
			while (cin.get() != '\n') {
				//i--;
				continue;// get rid of bad input
			}
			cout << "Please enter a number: ";
		   }
		   
	6.8 简单文件输入、输出
		简单的介绍文本文件I/O。
		6.8.1 文本I/O和文本文件
				。。。。。。
		6.8.2 写入到文本文件中
			有关将cout用于控制台输出的基本事实
			1. 必须包含头文件iostream。
			2. 头文件iostream定义了一个用处理输出的ostream类
			3. 头文件iostream声明了一个名为cout的ostream变量
			4. 必须指明使用名称空间：std；例如，为引用元素cout和endl，不许使用编译
			   指令using或前缀std::
			5. 可以结合使用cout和运算符<<来显示各种类型的数据
			文件输出与此类似
			1. 必须包含头文件fstream
			2. 头文件fstream定义了一个用于处理输出的ofstream类
			3. 需要声明一个或多个ofstream变量，并以自己喜欢的方式对其进行命名，条件是
			   遵守常用的命名规则
			4. 必须指明名称空间std；例如，为引用元素ofstream，必须使用编译指令using或
			   前缀std::.
			5. 需要将ofstream与文件关联起来。为此，方法之一就是使用open()方法。
			6. 使用完文件后，应使用方法close()将其关闭。
			7. 可以结合使用ofstream对象和运算符<<来输出各种类型的数据。
			必须声明自己的ofstream对象，为其命名，并将其同文件关联起来。
			ofstream outFile;
			ofstream fout;
			如何将这种对象与特定的文件关联起来。
			outFile.open("fish.txt"); //outFile used to write to the fish.txt file
			char filename[50];
			cin >> filename; //user specifies a name
			fout.open(filename);//fout used to read specified file
			
			方法open()接受一个C风格字符串作为参数，可以是一个字面字符串，也可以是一个
		存储在数组中的字符串。
			
			double wt = 124.8;
			outFile << wt; //write a number to fish.txt
			char line[81] = "Objects are closer than they appear.";
			fout << line << endl;
			
			方法close()不需要使用文件名作为参数。如果程序中忘记关闭文件，程序正常终止
		时将自动关闭。
			fstream 对象可以使用cout可使用的任何方法，包括<< 和各种格式化方法，如
		setf() 和 precision().
			
			open()方法。
			如果参数指定的文件不存在，则新建一个名为参数中指定的文件。如果指定的文件
		存在，则将原文件中的内容删除，等待新的操作。
		6.8.3 读取文本文件
			1. 必须包含头文件fstream
			2. 头文件fstream定义了一个用于处理输入的ifstream类
			3. 需要声明一个或多个ifstream变量（对象），并命名
			4. 必须指明名称空间std
			5. 需要将ifstream对象与文件关联起来，为此，方法之一是使用open（）方法
			6. 使用完文件后，应使用close（）方法将其关闭
			7. 可以使用ifstream对象和get（）方法来读取一个字符，使用ifstream对象
			   和getline（）方法来读取一行字符。
			8. 可以结合使用ifstream和eof(), fail()等方法来判断输入是否成功。
			9. ifstream对象本身被用作测试条件时，如果最后一个读取操作成功，它将被转换
			   为布尔值true，否则为false。
			   
		    如何声明ifstream对象，为其命名及同文件关联起来。
			ifstream inFile;//inFile an ifstream object 
			ifstream fin; //fin an ifstream object
			
			inFile.open("bowling.txt");//inFile used to read bowling.txt file
			char filename[50];
			cin >> filename;
			fin.open(filename);
			
			double wt;
			inFile >> wt;         //read a number from bowling.txt
			char line[81];
			fin.getline(line, 81);//read a line of text
			如果试图打开一个不存在的文件用于输入，将导致后面使用ifstream对象进行输入
		时失败。所以需要检查文件是否被成功打开，使用方法 is_open(),或good()方法。
			if (!inFile.is_open()) {
				exit(EXIT_FAILURE);
				
			}

第七章 函数――C++的编程模块
	函数的基本知识
	函数原型
	按值传递函数参数
	设计处理数组的函数
	使用const指针参数
	设计处理文本字符串的函数
	设计处理结构的函数
	设计处理string对象的函数
	设计调用自身的函数（递归）
	指向函数的指针
	7.1 复习函数的基本知识
	    要使用C++函数，必须完成下面的工作：
	    1. 提供函数定义
	    2. 提供函数原型
	    3. 调用函数
	    7.1.1 定义函数
	        没有返回值的函数
	        void functionName(parameterList) {
	            statements
	            return;    
	        }	
	        带返回值的函数
	        typeName funcitonName(parameterList)
            {
                statements
                return value;
            }
        7.1.2 函数原型和函数调用
            1. 为什么需要原型
            原型描述了函数到编译器的接口，即将函数返回值的类型以及参数的类型和数量告诉编译器。
            2. 原型的语法
            函数定义中的函数头加上分号。
            double cube(double x);
            3. 原型的功能
                1. 编译器正确的处理函数返回值
                2. 编译器检查使用的参数数目是否正确
                3. 编译器检查使用的参数类型是否正确，如果不正确，则转换为正确的类型（如果可能的话）
    7.2 函数参数和按值传递
        。。。。。。
    7.3 函数和数组
        将数组作为参数传递给函数
        int sum_arr(int arr[], int n);
        7.3.1 函数如何使用指针类处理数组
            int sum_arr(int *arr, int n);
        7.3.2 将数组作为参数意味着什么
            意味着将数组的位置（地址），包含的元素的种类（类型）以及元素数目提交给了函数。因此
        函数在处理参数传来的数组的时候，实际上就是在操作原来的数组。
		7.3.3 更多数组函数示例
			1. 填充数组
				int fill_array(double ar[], int limit);
				int fill_array(double ar[], int limit)
				{
					double temp;
					int i;
					for (i = 0; i < limit; i++) {
						cout << "Enter value #" << (i+1) << ": ";
						cin >> temp;
						if (!cin) {
							cin.clear();
							while(cin.get() != '\n') {
								continue;
							}
							cout << "Bad input; Input process terminated.\n";
							break;
						} else if (temp < 0) {
							break;
						}
						ar[i] = temp;
						
					}
					
					return i;
				}
			2. 显示数组及用const保护数组
				显示数组时，应保证函数不修改原始数组，此时可在声明形参时使用关键字
			const:
			void show_array(const double ar[], int n);
			3. 修改数组
				void revalue(double r, double ar[], int n)
				{
					for (int i = 0; i < n; i++) {
						ar[i] *= r;
						
					}
				}
			4. 将上述代码组合起来。
			
		7.3.4 使用数组区间的函数
		。。。。。。
		7.3.5 指针和const
			让指针指向一个常量对象
			将指针本身声明为常量
			int age = 39;
			const int *pt = &age;
			*pt的值为const，不能修改，但是age的值是可以修改的。
			将const变量的地址赋给const指针，这种方法可行
			尽可能使用const
			将指针参数声明为指向常量数据的指针有两条理由
			1. 这样可以避免由于无意间修改数据而导致的编程错误
			2. 使用const是的函数能够处理const和非const实参，否则只能接受非const数据。
			如果条件允许，则应将指针形参声明为指向const的指针。
			
	7.4 函数和二维数组
		int sum(int (*ar2)[4], int size);
		int sum(int ar2[][4], int size);
	7.5 函数和C-风格字符串
		C-风格字符串由一系列字符组成，以空字符结尾。
		7.5.1 将C风格字符串作为参数的函数
			三种表示字符串的方式
			1. char数组；
			2. 用引号括起来的字符串常量
			3. 被设置成字符串的地址的char指针
		7.5.2 返回C-风格字符串的函数
			char * buildster(char c, int n)
			{
			    char *pstr = new char[n + ];
				pstr[n] = '\0';
				while (n-- > 0) 
					pstr[n] = c;
				return pstr;
			}
	7.6 函数和结构
	7.6 函数和结构
		使用结构编程时，最直接的方法就是像处理基本类型那样来处理结构。
		7.6.1 传递和返回结构
			当结构比较小时，按值传递结构最合理。
			struct travel_time {
				int hours;
				int mins;
			};
			travel_time sum(travel_time t1, travel_time t2)
			{
				travel_time total;
				total.mins = (t1.mins + t2.mins) % Mins_per_hr;
				total.hour = (t1.hours + t2.hours) + (t1.mins + t2.mins) / Mins_per_hr;
				return total;
			}
			void show_time(travel_time t)
			{
				cout << t.hours << " hours, " << t.mins << " mins." << endl;
			}
		7.6.3 传递结构的地址
	7.7 函数和string对象
		可以将结构作为完整的实体传递给函数，也可以将对象作为完整的实体进行传递。
		void display(const string sa[], int n)
		{
			for (int i = 0; i < n; i++) {
				cout << i + 1 << ": " << sa[i] << endl;				
			}
		}
	7.8 函数与array对象
		C++中，类对象是基于结构的，因此结构编程方面的有些因素也适用于类。
	7.9 递归
		自己调用自己的函数就是递归。C++中不允许main（）调用自己。
		7.9.1 包含一个递归调用的递归
			如果递归函数中没有停止条件，则将无限循环下去。通常的做法是将递归调用，放在if语句中。
			void recurs(agumentlist)
			{
				statementsl
				if(test)
					recurs(arguments)
				statements2
			}
			只要if语句为true，每个recurs（）调用都将执行statements1，然后再调用recurs，而不会执行
		statement2.当if语句为false时，当前调用将执行statements2.当前调用结束后，程序控制权将返回给调用它的recurs（），
		而该recurs（）将执行是他tements2，然后结束，并将控制权返回前一个调用，以此类推。因此如果recurs进行了5次调用，
		则statement1部分将按函数的调用顺序调用5次，而statements将按相反的顺序调用5次。
		void countdown(int n)
		{
			cout << "Counting down ..." << n << endl;
			if (n > 0) {
				countdouwn(n - 1);
			}
			cout << n << ": Kaboom!\n";
		}
		
		7.9.2 包含多个递归调用的递归
			void subdivide(char ar[], int low, int high, int level)
			{
				if (level = 0) {
					return;
				}
			
				int mid = (high + low) / 2;
				ar[mid] = '|';
				subdivide(ar, low, mid, level - 1);
				subdivide(ar, mid, high, level - 1);
			}
	7.10 函数指针
		函数也有地址，函数的地址就是存储其机器语言代码的内存的开始地址。
		7.10.1 函数指针的基础知识
			1. 获取函数的地址
				只要使用函数名（后面不跟参数）即可。
			2. 声明函数指针
				类型 (*func)(参数列表);
			3. 使用指针来调用函数
				使用(*func)时，只需将它看成函数名就行了。
第8章 函数探幽
	内联函数
	引用变量
	如何按引用传递函数参数
	默认参数
	函数重载 
	函数模板
	函数模板具体化
	8.1 C++内联函数
		常规函数和内联函数之间的主要区别在于C++编译器如何将它们组合到程序中。
		1. 在函数声明前加上关键字 inline
		2. 在函数定义前加上关键字 inline
	8.2 引用变量
		引用变量是一种C++新增的复合类型。
		引用是已定义的变量的别名。引用变量的主要用途是用作函数的形参。通过将引用变量用作参数，函数将使用原始数据
	，而不是其副本。引用为函数处理大型结构提供了一种非常方便的途径。
		8.2.1 创建引用变量
			int rats;
			int &rodents = rats;
			这个时候&不是地址运算符，而是类型标识符的一部分，表明这个个引用变量。
		8.2.2 将引用作为函数参数
			引用经常被用作函数参数，使得函数中的变量名称为调用程序中的变量的别名。
		8.2.3 引用的属性和特别之处
			如果程序员的意图是让函数使用传递给它的信息，而不是对这些信息进行修改，同
		时又想使用引用，则应使用常量引用
			double refcube(const double &ar);
			如果这样做，当编译器发现代码修改了ra的值时，将发生错误消息。
			
		8.2.4 将引用用于结构
			引用非常适合于结构和类。使用结构引用参宿的方式与使用基本变量引用相同，
		只需在声明结构参数时使用引用运算符&。
			struct free_throws {
			    std:: string name;
				int made;
				int attempts;
				float percent;
			};
			void set_pc(free_throws & ft);
			
			free_throws & accumulate(free_throws & target, const free_throws & source)
			{
				......
				return target;
			};
			使用返回引用时，应避免返回函数终止时不再存在的内存单元引用
			
		8.2.5 将引用用于类对象
			将类对象传递给函数时，C++通常的做法是使用引用。
			string version1(const string & s1, const string & s2)
			{ 
				string temp;
				temp = s2 + s1 + s2;
				return temp;
			}
			const string & version2(string & s1, const string & s2)
			{
				s1 = s2 + s1 + s2;
				return s1;
			}
		8.2.6 对象，继承和引用
			派生类继承了基类的方法，基类引用可以指向派生类对象，而无需进行强制类型
		转换。
		8.2.7 何时使用引用参数
			使用引用参数的主要原因有两个：
			+	1. 程序员能够修改调用函数中的数据对象
				2. 通过传递引用而不是整个数据对象，可以提高程序的运行速度
			指导原则
				对于使用传递的值而不作修改的函数。
				1. 如果数据对象很小，如内置数据类型或小型结构，则按值传递
				2. 如果数据对象是数组，则使用指针，因为这是唯一的选择，并将指针声明为
				   指向const的指针
				3. 如果数据对象是较大的结构，则使用const指针或const引用，以提高程序的
				   效率。这样可以节省复制结构所需的时间和空间。
				对于修改调用函数中数据的函数
				4. 如果数据对象是类对象，则使用const引用。类设计的语句常常妖气使用引
				   用。传递类对象参数的标准方式是按引用传递。
				5. 如果数据对象是内置数据类型，则使用指针。
				6. 如果数据对象是数组，则只能使用指针
				7. 如果数据对象是结构，则使用引用或指针。
				8. 如果数据是类对象，则使用引用
	8.3 默认参数
		默认参数是指当函数调用中省略了实参时自动使用的一个值。
		可以通过函数原型来设置默认值，方法是将值赋给原型中的参数。例如：
		char * left(const *str, int n = 1);
		对于带参数列表的函数，必须从右往左添加默认值，既是，要为某个参数设置默认值，
	则不许位她右边的所有参数提供默认值。
		int harpo(int n, int m = 4, int j = 5);//valid
		int chico(int n, int m = 6, int j); //invalid
		int groucho(int k = 1, int m = 2, int n = 3);//valid
	8.4 函数重载
		函数多态是C++在c语言的基础上新增的功能。
		函数多态也就是函数重载，可以使用多个同名的函数。
		函数名相同，参数列表不同。
	8.5 函数模板
		函数模板，是通用的函数描述，也就是说，它们使用泛型来定义函数，其中的泛型可用
	具体的类型（如int或double）来替换。
		template <typename AnyType>
		void Swap(AnyType &a, AnyType &b)
		{
			AnyType temp;
			temp = a;
			a = b;
			b = temp;
		}
		必须template 和typename,
		必须使用尖括号
		模板并不创建任何函数，而只是告诉编译器如何定义函数。
		8.5.1 重载的模板
			需要多个对不同类型使用同一算法的函数时，可使用模板。然而并非所有的类型
		都使用相同的算法。可以像重载常规函数定义那样重载模板定义。
			template <typename T>
			void swap(T &a, T &b);
			template <typename T>
			void swap(T *a, T *b, int n);
		8.5.2 模板的局限性
			当模板函数在处理结构，数组等复合类型的时候是存在局限性的。
		8.5.3 显示具体化
			第三代具体化
			1. 对于给定的函数名，可以有非模板函数，模板函数和显示具体化模板函数以及
			   它们的重载版本。
			2. 显示具体化的原型和定义应以template<>开头，并通过名称来指出类型。
			3. 具体化优先于常规模板，而非模板函数优先于具体化和常规模板。
			例子：用于交换job结构的非模板函数，模板函数和具体化的原型
				struct job
				{
					char name[40];
					double salary;
					int floor;
				};
				//非模板函数
				void swap(job &, job &);
				
				//模板函数
				template <typename T>
				void swap(T &, T &);
				
				//具体化函数
				template <> void swap<job>(job &, job &);
				template <> void swap(job &, job &);
		8.5.4 实例化和具体化
第9章 内存模型和名称空间
	单独编译
	存储持续性，作用域和连接性
	定位new运算符
	名称空间
	9.1 单独编译
		C++允许并鼓励程序员将组件函数放在独立的文件中。
		头文件：包含结构声明和使用这些结构的函数的原型
		源代码文件：包含与结构相关的函数的代码
		源代码文件：包含调用与结构相关的函数的代码
		头文件中常包含的内容
			1. 函数原型
			2. 使用#define或constant定义的符号常量
			3. 结构声明
			4. 类声明
			5. 模板声明
			6. 内联函数
			包含自己的头文件时，应是哦那个引号而不是尖括号。这是因为包含头文件时，使用
		尖括号和引号时，编译器在查找时的顺序是不同的。使用尖括号时，比那一起将在存储标
		准头文件的主机系统的文件系统中查找。但如果使用引号，则编译器将首先查找当前工程
		目录或源代码目录。如果没有在哪里找到头文件，则将在标准位置查找。
			单独编译其实讲的就是将工程分成不同的文件进行单独编程。通过头文件的创建和包含，
		将多个文件组合成一个工程。同时由于文件是单独编译的，所以在修改某个功能时，只需
		修改该功能所在文件即可，而不用修改别的文件。达到简化开发的目的。
	9.2 存储持续性，作用域和连接性
		C++使用三种不同的方案来存储数据，这些方案的区别就在于数据保存在内存中的时间。
	C++11 中有四种方案。
		1. 自动存储持续性：在函数定义中声明的变量（包括函数参数）的存储持续性为自动
		   它们在程序开始执行其所属的函数或代码块时被创建，在执行玩函数或代码块时，
		   它们使用的内存被释放。C++有两种存储持续性位自动的变量
		2. 静态存储持续性：在函数定义外定义的变量和使用关键字static定义的变量的存储持
		   性都为静态。它们在程序整个运行过程中都存在。C++有三种存储持续性位静态的变量
		3. 线程存储持续性（C++）：当前，多核处理器很常见，这些CPU可同时处理多个执行任务。
		   这让程序能够将计算放在可并行处理的不同线程中。如果变量使用关键字thread_local
		   声明的，则其生命周期与所属线程一样长。
	    4. 动态存储持续性：用new运算符分配的内存将一直存在，知道使用delete运算符将其
		   释放或程序结束为止。这种内存的存储持续性为动态，有时称为自由存储或堆。
		9.2.1 作用域和链接
			作用域描述了名称在问啊进的多大范围内可见。
			连接性描述了名称如何在不同单元之间共享。连接性为外部的名称可在文件间共享
			，连接性位内部的名称只能由一个文件中的函数共享。
		9.2.2 自动存储持续性
			默认情况下，在函数中声明的函数参数和变量的存储持续性位自动，作用域为局部
		，没有连接性。
			如果在代码块中定义了变量，则该变量的存在时间和作用域被限制在该代码块中。
			1. 自动变量的初始化
				可以使用任何在声明时其值为已知的表达式来初始化自动变量
			2. 自动变量和栈
				自动变量存放在栈中，栈用来管理自动变量，采用后进先出的管理方法。
			3. 寄存器变量
				关键字 register 它建议编译器使用CPU寄存器来存储自动变量。
					register int count_fast;
				旨在提高访问变量的速度。
				在C++11 中，其作用只是显示的指出变量是自动的。
		9.2.3 静态持续变量
			C++为静态存储持续性变量提供了三种连接性：外部链接性，内部连接性和无连接性。
		如果没有显示的初始化静态变量，编译器将把它设为0.在默认情况下，静态数组和结构将每
		个元素或成员所在的位置都设置为0
			int global = 1000;        //static duration, external linkage
			static int one_file = 50; // static duration, internal linkage
			int main()
			{
				......
			}
			void funct1(int n)
			{
				static int count = 0; // static duration, no linkage
				int llama = 0;
				......
			}
			void function2(int q)
			{
				
			}
		9.2.4 静态持续性，外部连接性
			链接性为外部的变量通常简称为外部变量，它们的存储持续性位静态，作用域为整
		个文件
			1. 单定义规则
				单定义规则指出，变量只能有一次定义。C++提供了两种变量声明，一种是定义
			声明，一种是引用声明。可以满足单定义原则。
			引用声明使用关键字extern,且不进行初始化，否则声明位定义，导致分配内存空间。
				extern int blem;
			如果要在多个文件中使用外部变量，只需在一个文件中包含该变量的定义，但在使用该
			变量的其他所有文件中，都必须使用关键字extern声明它。
		9.2.5 静态持续性，内部链接性
			将static限定符用于作用域位整个文件的变量时，该变量的链接性位内部的。链接性为内部的变量只能在其所属
		的文件中使用。
			在多文件程序中，可以在一个文件中（且只能在一个文件）中定义一个外部变量。使用该变量的其他文件必须使用
		关键字extern声明它。
			可使用外部变量在多文件程序的不同部分之间共享数据。
			可使用链接性位内部的静态变量在同一个文件中的多个函数之间共享数据。
			如果将作用域为整个文件的变量变为静态的，就不必担心其名称与其他文件中的作用域为整个文件的变量发生冲突。
		9.2.6 静态存储持续性，无链接性
			将static限定符用于在代码块中定义的变量。这意味着虽然该变量只在该代码块中可用，但它在该代码块不处于活动
		状态时仍然存在。
		9.2.7 说明符和限定符
			存储说明符
				auto
				register
				static
				extern
				thread_local
				mutable
			同一个声明中不能使用多个说明符，但thread_local除外，可与static或extern结合使用。
			1 cv-限定符
				const
				volatile
				volatile表明，即使程序代码没有对内存单元进行修改，其值也可能发生变化。该关键字的作用是为了改善编译器的
			的优化能力。
			2. mutable
				可以用它指出，即使结构（或类）变量位const，其某个成员也可以被修改。例如
				struct data {
					char name[30];
					mutable int accesses;
					......
				};
		9.2.8 函数和链接性
			C++不允许在一个函数中定义另外一个函数，因此所有函数的存储持续性都自动为静态的，即在整个程序执行期间都
		一直存在。
		9.2.9 语言链接
			语言链接性主要是为了函数重载而生的，为重载函数生成不同的符号名称。
		9.2.10 存储方案和动态分配
			动态内存，由运算符new和delete控制。
				
	9.3 名称空间
		名称空间就是用来解决名称冲突的。
		9.3.1 传统的C++名称空间
			声明区域。声明区域是可以在其中进行声明的区域。
			潜在作用域。变量的潜在作用域从声明点开始，到其声明区域的结尾。
		9.3.2 新的名称空间特性
			通过定义一种新的声明区域来创建命名的名称空间。这样做的目的之一是提供一个声明名称的区域。一个名称
		空间中的名称不会与另外一个名称空间的相同名称发生冲突。
			namespace Jack {
				double pail;
				void fetch();
				int pal;
				struct well {};
			}
			namespace Jill {
				double bucket(double n) {};
				double fetch;
				int pal;
				struct Hill{};
			}
			名称空间可以是全局的，也可以位于另一个名称空间中，但不能位于代码块中。
			使用作用域解析运算符:: 来访问名称空间中的名称。
			Jack::pail = 12.34;
			Jill::Hill mole;
			Jack::fetch();
			1. using 声明和 using 编译指令
			using 声明和 using 编译指令可以简化对名称空间中名称的使用。
			using 声明由限定符它的名称和它前面的关键字using组成：
			using Jill::fetch;
			using 声明将特定的名称添加到它所属的声明区域中。使用该声明后，便可以名称fetch代替Jill::fetch.
			在函数外面使用using声明，将把名称添加到全局名称空间中。
			using声明使一个名称可用，而using编译指令使所有名称都可用。
			using namespace Jill;
			在全局声明区域中使用using编译指令，将使该名称空间的名称全局可用。
			在函数中使用using编译指令，将使其中的名称在该函数中可用。
			2. using 编译指令和 using 声明之比较
				编译指令是全部代入，而声明只针对指定的名称。
			3. 名称空间的其他特性
				可以将名称空间声明进行嵌套
				namespace elements {
					namespace fire {
						int flame;
						....
					}
					float water;
				}
				
				elements::fire::flame;
				using namespace elements::fire;
				可以在名称空间中使用using编译指令和using声明
				namespace myth {
					using Jile::fetch;
					using namespace elements;
					using std::cout;
					using std::cin;
				}
			4. 未命名的名称空间
				可以通过省略名称空间的名称来创建未命名的名称空间：
				namespace {
					int ice;
					int bandycoot;
				}
				由于这种名称空间没有名称，因此不能显示的使用using编译指令或using声明来使它在其他位置都可用。
		9.3.4 名称空间及其前途
			指导原则
			1. 使用已命名的名称空间中声明的变量，而不是使用外部全局变量
			2. 使用已命名的名称空间中声明的变量，而不是使用静态全局变量
			3. 如果开发一个函数库或类库，将其放在一个名称空间中。
			4. 仅将编译指令using作为一种将旧代码转换位使用名称空间的权宜之计。
			5. 不要在头文件中使用using编译指令。
			6. 导入名称时，首先使用作用域解析运算符或using声明的方法
			7. 对于using声明，首选将其作用域设置位局部而不是全局。
	9.4 总结
		使用头文件来定义用户类型，为操作用户类型的函数提供函数原型；并将函数定义放在一个独立的源代码文件中。
	头文件和源代码文件一起定义和实现了用户定义的类型及其使用方式。最后将main（）和其他使用这些函数的函数放在
	第三个文件中。
	
第10章 对象和类